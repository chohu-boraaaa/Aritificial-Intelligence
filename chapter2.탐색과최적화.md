# 탐색
- 문제의 해가 될 수 있는 집합을 공간이라고 하고 문제에 대한 최적의 해를 찾기 위해 공간을 체계적으로 찾아보는 것
- 선교사-식인종 강건너기 문제, 틱택토, 루빅스큐브, 8-퍼즐, 8-퀸, 순회판매자문제
- 해 : 일련의 동작으로 구성되거나 하나의 상태로 구성

## 상태
- 상태 : 특정 시점에 문제의 세계가 처해 있는 모습

## 세계
- 문제에 포함된 대상들과 이들의 상황을 포괄적으로 지칭

## 상태공간
- 문제 해결 과정에서 초기상태에서 도달할 수 있는 모든 상태의 집합
- 문제의 해가 될 가능성이 있는 모든 상태의 집합
- 초기상태 : 문제가 주어진 시점의 초기 상태
- 목표상태 : 문제에서 원하는 최종 상태

## 상태공간 그래프
- 상태공간에서 각 행동에 따른 상태의 변화를 나타낸 그래프
- 노드 : 상태, 링크(에지) : 행동
- 해 : 초기상태에서 목표상태로의 경로
- 일반적 문제는 상태공간이 너무 커서 탐색과정에서 그래프 생성

## 맹목적 탐색
- 정해진 순서에 따라 상태공간 그래프를 점진적으로 생성해 가면서 해를 탐색하는 방법

### 깊이 우선 탐색
- 초기 노드에서 깊이 방향으로 탐색
- 목표 노드에 도달하면 종료
- 더 이상 진행할 수 없으면 백트래킹(되짚어가기) -> 방문한 노드 재방문하지 않으므로 메모리 절약 가능
- 방문한 노드는 재방문하지 않음
- 루트 노드에서 현재 노드까지 경로 하나만 유지
- 최단거리 보장 X

### 너비 우선 탐색
- 초기노드에서 모든 자식 노드 확장하여 생성
- 목표노드 없으면 단말노드에서 다시 자식노드 확장
- 전체트리를 메모리에서 관리하므로 불이익, 최단거리 보장

### 반복적 깊이 심화 탐색
- 깊이 한계가 있는 깊이 우선 탐색을 반복적 적용
- 메모리 효율, 최단 경로 보장
- 각 노드가 10개의 자식노드 가질 때 너비우선탐색 대비 11%정도 추가 노드 생성 -> 실제 비용이 크게 늘지 않음
- 맹목적 탐색 적용시 우선 고려 대상

### 양방향 탐색
- 초기 노드와 목적 노드에서 동시에 너비 우선 탐색
- 중간에 만나도록 해서 목표노드까지 최단 경로 찾는 것

### 아일랜드 탐색
- 중간중간 띄워놓고 연결

## 정보이용 탐색
- 휴리스틱 탐색 : 시간이나 정보가 불충분하여 합리적 판단할 시간이 없거나 굳이 합리적 판단을 하지 않아도 될 상황에서 신속하게 어림짐작하는 것

### 최단경로 문제
- 현재 위치에서 목적지까지 직선거리

### 8-퍼즐 문제
- 제자리에 있지 않은 타일의 개수

### 8-퀸 문제
- 충돌하는 횟수

### 언덕오르기 방법
- 지역 탐색, 휴리스틱 탐색
- 현재노드에서 휴리스틱 평가값이 가장 좋은 이웃 노드 하나를 확장해 가는 탐색 방법
- 국소 최적해에 빠질 가능성

### 최상 우선 탐색
- 확장 중인 노드들 중에서 목표노드까지 남은 거리가 가장 짧은 노드를 확장하여 탐색
- 남은 거리를 정확히 알 수 없이 휴리스틱 사용 ex. 8-퍼즐 문제에서 제자리가 아닌 타일 개수

### 빔 탐색
- 휴리스틱에 의한 평가값이 우수한 일정 개수의 확장 가능한 노드들을 가지고 메모리에 관리하면서 최상 우선 탐색 적용

### A* 알고리즘
- 추정한 전체 비용을 최소로하는 노드를 확장해나가는 방법
- 전체 비용 = 이미 투입된 비용 + 남은 비용
- 남은 비용 정확히 예측 불가 -> 전체 비용에 대응하는 휴리스틱 함수 = 이미 투입된 비용 + 남은 비용에 대응하는 휴리스틱 함수 = 노드 n을 경유하는 추정 전체 비용

## 게임에서의 탐색
- 상대가 있는 게임에서 자신과 상대방의 가능한 게임 상태 나타낸 트리
- 틱택톡, 바둑, 장기, 체스 등
- 게임의 결과는 마지막에 결정
- 많은 수를 볼 수록 유리

### mini-max 알고리즘
- max 노드 : 자신에게 해당하는 노드, 자기에게 유리한 최대값 선택
- min 노드 : 상대방에 해당하는 노드, 최소값 선택
- 단말노드부터 위로 올라가면서 최소-최대 연산을 반복하여 자신이 선택할 수 있는 방법 중 가장 좋은 것 결정
- 전체 구조 알 필요는 없음
- 노드에 적힌 숫자들 : 판세 평가값

### 알파-베타 가지치기(prunning)
- 검토해볼 필요가 없는 부분을 탐색하지 않도록 하는 기법
- 깊이 우선 탐색으로 제한 깊이까지 탐색하면서 max노드와 min노드 결정
- 알파 자르기 : MIN 노드의 현재값이 부모노드의 현재값보다 작거나 같으면 나머지 자식노드 탐색 중지
- 베타 자르기 : MAX 노드의 현재값이 부모노드의 현재값보다 크거나 같으면 나머지 자식노드 탐색 중지

### 몬테카를로 시뮬레이션
- 특정 확률분포로부터 무작위 표본을 생성
- 이 표본에 따라 행동하는 과정을 반복하여 결과 확인
- 결과확인 과정 반복하여 최종 결정
- 무작위로 시뮬레이션 한 후 승률을 계산하여 형세값으로 이용
- 탐색 공간을 무작위 표본추출하여 탐색트리를 확장하여 가장 좋아보이는 것을 선택하는 휴리스틱 탐색 기법
- 판의 형세판단을 위해 휴리스틱 대신 가능한 많은 수의 몬테카를로 시뮬레이션 수행
- 일정 조건을 만족하는 부분은 트리로 구성 / 나머지는 몬테카를로 시뮬레이션 : 가능성이 높은 수들에 대해서는 노드를 생성하여 트리의 탐색 폭을 줄이고 트리 깊이를 늘리지 않기 위해 몬테카를로 시뮬레이션 적용 -> 탐색 

#### 동작 선택 방법
- 가장 승률이 높은 루트의 자식 노드 선택
- 가장 빈번하게 방문한 루트의 자식 노드 선택
- 승률과 빈도가 가장 큰 루트의 자식노드 선택, 없으면 조건을 만족하는 것이 나올때까지 탐색 반복
- 자식노드의 confidence bound(손자들의 UCB)값의 최소값이 가장 큰, 루트의 자식 노드 선택

<4단계 반복>
#### 선택 : 트리 정책 적용
- 루트노드에서 시작
- 정책에 따라 자식노드를 선택하여 단말노드까지 내려 감
- 승률과 노드 방문횟수 고려하여 선택
- UCB 정책 : UCB가 큰 것 선택, UCB=활용+탐색 (승률이 높아보인다고(활용) 그대로 따라가면 딜레마 빠질 수 있음 -> 시도해보지 못한 게 있을 수 있음(탐험))

#### 확장 
- 단말노드에서 트리정책에 따라 노드 추가

#### 시뮬레이션
- 기본정책에 의한 몬테카를로 시뮬레이션 적용
- 무작위 선택 또는 약간 똑똑한 방법으로 게임 끝날 때까지 진행

#### 역전파
- 단말노드에서 루트노드까지 올라오면서 승점 반영

#### 알파고의 탐색
- 바둑판 형세판단
- 무작위로 바둑을 두는 것이 아닌 프로 바둑기사들의 기보를 학습한 확장 정책망이라는 간단한 계산 모델 사용
- 정책망 : 가능한 착수들에 대한 선호 확률분포
- 가치망 : 바둑판의 형세 값을 계산하는 계산모델
- 확률에 따라 착수를 하여 몬테카를로 시뮬레이션을 반복하여 해당 바둑판에 대한 형세판단값 계산
- 별도로 학습된 딥러닝 신경망인 가치망을 사용하여 형세판단값을 계산하여 함께 사용

## 제약조건 만족 문제
- 주어진 제약조건을 만족하는 조합 해를 찾는 문제
- ex. 8-퀸

### 백트래킹 탐색
- 깊이 우선 탐색을 하는 것처럼 변수에 허용되는 값을 하나씩 대입
- 모든 가능한 값을 대입해서 만족하는 것이 없으면 이전단계로 돌아가서 이전 단계의 변수에 다른 값 대입

### 제약조건 전파
- 인접 변수 간 제약 조건에 따라 각 변수에 허용될 수 없는 값들을 제거하는 방식

# 최적화
- 여러가지 허용된 값들 중에서 주어진 기준을 가장 잘 만족하는 것을 선택하는 것
- 목적함수 : 최소 또는 최대가 되게 하려는 함수

## 조합 최적화
- 순회 판매자 문제(TSP), 스케줄링 문제 등과 같이 항목들의 조합으로 해가 표현되는 최적화 문제

### 순회 판매자 문제(TSP)
- 목적함수 : 경로의 길이
- 후보해 경로조합(휴리스틱 이용)

### 유전 알고리즘
- 생물의 진화를 모방한 집단 기반의 확률적 탐색 기법
- 대표적 진화 연산

#### 생물의 진화
- 염색체의 유전자들의 개체 정보 코딩
- 적자생존/자연선택
- 집단의 진화
- 형질 유전과 변이 : 부모에게 교차 상속, 돌연변이

#### 생물의 진화와 문제해결
- 개체 : 후보해
- 환경 : 문제
- 적합도 : 해의 품질
- 절차 : 초기 모집단 생성 -> 적합도 함수로 적합도 평가 -> 종료조건 만족:최적 개체 -> 만족하지 않으면 부모 개체 선택(진화) -> 유전연산자 이용하여 자식 개체 생성 -> 새로운 모집단 생성 -> 다시 반복
- 후보해 표현 : 염색체 표현
- 모집단 : 동시에 존재하는 염색체들 집합
- 적합도 함수 : 후보해가 문제의 해로서 적합한 정도를 평가하는 함수
- 부모 개체 선택(selection) : 높은 적합도의 개체가 새로운 개체를 생성할 확률이 높도록 함 (적합도에 비례하는 선택확률)
- 유전연산자(genetic operator) : 새로운 개체 생성 (항상 좋아진다는 보장은 없음) : 교차 연산자, 돌연변이 연산자
- 세대 교체 : 엘리트 주의 : 우수한 개체를 다음 세대에 유지

### 메타 휴리스틱
- 최적해는 아니지만 우수한 해를 빠르게 찾기 위한 휴리스틱적인 문제해결 전략
- 유전 알고리즘, 모방 알고리즘, 입자 군집 최적화, 개미 집단 알고리즘, 타부 탐색, 담금질 기법, 하모니 탐색, 유전 프로그래밍

## 함수 최적화
- 어떤 목적함수가 있을 때 이 함수를 최대로 하거나 최소로 하는 변수값을 찾는 최적화 문제

### 경사하강법
- 복잡한 함수의 경우 임의의 위치에서 시작하여 함수 f(x)의 그래디언트 반대방향으로 조금씩 움직이면서 최적의 변수값을 찾으려는 방법
- 그래디언트 : 각 변수에 대해 편미분한 벡터
- 탐색 중의 매 위치에서 그래디언트를 계산하여 반대방향으로 이동하도록 변수의 값을 반복적으로 조금씩 조정 (0<학습율<1)
- 그래디언트 0이 되도록 최적 위치 찾는 것
- 함수 값이 최적이 되도록 변수 값 변경하는 일
- local minimum이 전체적 최소값이라는 보장은 없음

### 제약조건 최적화
- 제약조건을 만족하면서 목적함수를 최적화하는 변수들의 값을 찾는 문제
- SVM 학습에서 사용

#### 최적화 방법
- 등식 제약조건의 구성하는 함수가 0보다 크면 양수인 람다를 선택해서 크게 만들 수 있고 0보다 작으면 음수인 람다를 선택해서 크게 만들 수 있다 -> 즉 등식 제약조건이 만족하는 것 중 선택하게 됨
- 부등식 제약조건을 구성하는 함수는 알파가 0이상이기 때문에 0 이하인 등식 제약조건이 만족하는 것 중에서 선택하게 됨
- 쌍대함수를 최대화하면서 상보적 여유성을 만족하는 x1, x2를 구함. 알파*g(x1,x2)=0, (알파>=0)

### 이차 계획법
- 목적함수가 볼록 이차식이고 제약조건이 모두 일차식인 최적화 문제
